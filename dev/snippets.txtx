# code snippets;

Assume a(7) is used as base value for determining the order/size of the finite field

if(a(idx) == a(7)) then order = idx - 7;

1, 19, 2345, ?, ?, a(6), a(7), ...

Assume order = 4 then we may have a(7), b, c, d, a(7), b, |c| at the end of the sequence a(1e5)

in this case (n - 6) % order 4 => 3. The required offset from a(7) is + 2.

therefore (residue - 1) = 3 - 1 = +2	ending c:

for ending b: residue     2 - 1 = +1

for ending a7: residue    1 - 1 =  0

for ending d: residue     0 - 1 = -1. this indexes a(7-1) -> a(6) which is a valid quantity for
large modulus (1e9 + 1e3 ... 1e7)
or:
if(offset < 0) offset += order	-1 + 4 = 3 => 'd' as required

Assume a(idx) matches a(7) and vector blocks[ idx // 1000 ] = some value of a @ idx*1000.

The target index will be 7 + offset calculated above. To facilitate this we use the itermediate 
values of index//1000 and 'a' stored in the blocks vector.

Assume we have found a large order (24567) and found a smaller offset 12345 
Therefore target-index= 7 + 12345 = 12352.

let j = 12352 // 1000 = 12

if ( j > 0 ) {

	let a = block[j] and i = j*1000
	
} else { // e.g. where (6 <= target-index < 1000)

	let a = 1 and i = 1;
	
}

while (i != target-index) {
	a = (6*a*a + 10*a + 3) % prime;
	i += 1;
}
// Now a has same value as a[1e5] as required.

order = 10 and offset = -1 the target-index = 7 + (-1) = 6

order = 1234 and offset = 729 target-index 7 + 729 = 736 (< 1000)

